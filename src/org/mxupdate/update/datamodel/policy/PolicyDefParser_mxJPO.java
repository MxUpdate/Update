/* Generated By:JavaCC: Do not edit this line. PolicyDefParser.java */
package org.mxupdate.update.datamodel.policy;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import matrix.db.Context;

import org.mxupdate.update.datamodel.Policy_mxJPO;
import org.mxupdate.util.TypeDef_mxJPO;

public class PolicyDefParser_mxJPO implements PolicyDefParserConstants_mxJPO {
  public static void main(String args[]) {
    System.out.println("Reading from standard input...");
//    new eg2(System.in);
PolicyDefParser_mxJPO e = new PolicyDefParser_mxJPO(new java.io.StringReader(
"  description \"Policy used for all Products\\\" within the Bosch eADM application.\"\n"
+ "  type {\"Products\"}\n"
+ "  format {{a \"{a}} b c}\n"
+ "  defaultformat a\n"
+ "  sequence \"1,2,3,...\"\n"
+ "  store \"STORE\"\n"
+ "  hidden \"false\"\n"
+ "  state \"InWork\"  {\n"
+ "    registeredName \"state_InWork\"\n"
+ "    revision \"true\"\n"
+ "    version \"true\"\n"
+ "    promote \"true\"\n"
+ "    checkouthistory \"true\"\n"
+ "    owner {read modify promote fromconnect toconnect fromdisconnect todisconnect show}\n"
+ "    public {none}\n"
+ "    user \"Access Grantor\" {read grant revoke show}\n"
+ "    user \"RBN_ProductManager\" {create}\n"
+ "    user \"RBN_PublicChangeName\" {changename} filter \"(context.user == owner) && (id == first.id)\"\n"
+ "    user \"Shadow Agent\" {all}\n"
+ "    action \"a1\" input \"a3\"\n"
+ "    check \"c1\" input \"c3\"\n"
+ "    route {tmo tma tmoa2} \"route message\""
+ "    signature \"FinalReject\" {\n"
+ "      branch \"Canceled\"\n"
+ "      approve {a1 a2 a3}\n"
+ "      ignore {b1 b2 b3}\n"
+ "      reject {c1 c2 c3}\n"
+ "      filter \"(attribute[RBN_FinalRejectReason] != \\\"\\\")\"\n"
+ "    }\n"
+ "  }\n"
+ "  state \"InReview\"  {"
+ "    registeredName \"state_InReview\""
+ "    revision \"false\""
+ "    version \"false\""
+ "    promote \"false\""
+ "    checkouthistory \"false\""
+ "    owner {read promote demote show}"
+ "    public {none}"
+ "    user \"Access Grantor\" {read grant revoke show}"
+ "    user \"Shadow Agent\" {all}"
+ "    action \"\" input \"\""
+ "    check \"\" input \"\""
+ "    trigger promote check \"emxTriggerManager\" input \"PolicyRBN_ProductsInReviewPromoteCheck\""
+ "  }"));
    try {
    Policy_mxJPO n = e.policy();
//      SimpleNode_mxJPO n = eg2.Start();
//      n.dump("");

        final Method method = n.getClass().getDeclaredMethod("prepare", Context.class);
        final boolean accessible = method.isAccessible();
        try  {
            method.setAccessible(true);
            method.invoke(n, (Context) null);
        } finally  {
            method.setAccessible(accessible);
        }
      System.out.println("Thank you."+n);

    } catch (Exception ex) {
      System.out.println("Oops.");
      System.out.println(ex.getMessage());
    }
  }


    protected static void setValue(final Object _object,
                                   final String _fieldName,
                                   final String _value)
    {
try  {
        final Field field = getField(_object, _fieldName);
        final boolean accessible = field.isAccessible();
        try  {
            field.setAccessible(true);
            final Class<?> type = field.getType();
            if ("boolean".equals(type.getName()))  {
                field.setBoolean(_object, Boolean.parseBoolean(_value));
            } else  {
                field.set(_object, _value);
            }
        } finally  {
            field.setAccessible(accessible);
        }
} catch (Exception e)  {
    e.printStackTrace();
}
    }

    protected static void setValue(final Object _object,
                                   final String _fieldName,
                                   final Collection<?> _values)
    {
try  {
        final Field field = getField(_object, _fieldName);
        final boolean accessible = field.isAccessible();
        try  {
            field.setAccessible(true);
            final Collection<Object> set = (Collection<Object>) field.get(_object);
            set.addAll(_values);
        } finally  {
            field.setAccessible(accessible);
        }
} catch (Exception e)  {
    e.printStackTrace();
}
    }

    protected static void appendValue(final Object _object,
                                      final String _fieldName,
                                      final Object _value)
    {
try  {
        final Field field = getField(_object, _fieldName);
        final boolean accessible = field.isAccessible();
        try  {
            field.setAccessible(true);
            final Collection<Object> collection = (Collection<Object>) field.get(_object);
            collection.add(_value);
        } finally  {
            field.setAccessible(accessible);
        }
} catch (Exception e)  {
    e.printStackTrace();
}
    }

    /**
     * Searches for given name the field within the object.
     *
     * @param _object       object where the field is searched
     * @param _fieldName    name of searched field
     * @return found field
     */
    protected static Field getField(final Object _object,
                                    final String _fieldName)
    {
        Class<?> clazz = _object.getClass();
        Field field = null;
        try  {
            field = clazz.getDeclaredField(_fieldName);
        } catch (NoSuchFieldException e)  {
        }
        while ((field == null) && (clazz != null))  {
            clazz = clazz.getSuperclass();
            if (clazz != null)  {
                try  {
                    field = clazz.getDeclaredField(_fieldName);
                } catch (NoSuchFieldException e)  {
                }
            }
        }
        return field;
    }

  final public Policy_mxJPO policy() throws ParseException_mxJPO {
    final Policy_mxJPO policy = new Policy_mxJPO(TypeDef_mxJPO.Policy);
    String tmp;
    Set<String> set;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DESCRIPTION:
      case TYPE:
      case FORMAT:
      case STORE:
      case DEFAULTFORMAT:
      case SEQUENCE:
      case HIDDEN:
      case STATE:
        ;
        break;
      default:
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DESCRIPTION:
        jj_consume_token(DESCRIPTION);
        tmp = sString();
                                         setValue(policy, "description", tmp);
        break;
      case TYPE:
        jj_consume_token(TYPE);
        set = lList();
                                         setValue(policy, "types", set);
        break;
      case FORMAT:
        jj_consume_token(FORMAT);
        set = lList();
                                         setValue(policy, "formats", set);
        break;
      case DEFAULTFORMAT:
        jj_consume_token(DEFAULTFORMAT);
        tmp = sString();
                                         setValue(policy, "defaultFormat", tmp);
        break;
      case SEQUENCE:
        jj_consume_token(SEQUENCE);
        tmp = sString();
                                         setValue(policy, "sequence", tmp);
        break;
      case STORE:
        jj_consume_token(STORE);
        tmp = sString();
                                         setValue(policy, "store", tmp);
        break;
      case HIDDEN:
        jj_consume_token(HIDDEN);
        tmp = sString();
                                         setValue(policy, "hidden", tmp);
        break;
      case STATE:
        state(policy);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException_mxJPO();
      }
    }
    {if (true) return policy;}
    throw new Error("Missing return statement in function");
  }

  final public void state(final Policy_mxJPO _policy) throws ParseException_mxJPO {
    final Policy_mxJPO.State state = new Policy_mxJPO.State();
    String tmpStr;
    Set<String> tmpSet;
    jj_consume_token(STATE);
    tmpStr = sString();
                                setValue(state, "name", tmpStr);
    jj_consume_token(77);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REGISTEREDNAME:
      case REVISION:
      case VERSION:
      case PROMOTE:
      case CHECKOUTHISTORY:
      case OWNER:
      case PUBLIC:
      case USER:
      case ACTION:
      case CHECK:
      case TRIGGER:
      case SIGNATURE:
      case ROUTE:
        ;
        break;
      default:
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REGISTEREDNAME:
        jj_consume_token(REGISTEREDNAME);
        tmpStr = sString();
                                                    setValue(state, "nameSymbolic", tmpStr);
        break;
      case REVISION:
        jj_consume_token(REVISION);
        tmpStr = sString();
                                                    setValue(state, "revisionable", tmpStr);
        break;
      case VERSION:
        jj_consume_token(VERSION);
        tmpStr = sString();
                                                    setValue(state, "versionable", tmpStr);
        break;
      case PROMOTE:
        jj_consume_token(PROMOTE);
        tmpStr = sString();
                                                    setValue(state, "autoPromotion", tmpStr);
        break;
      case CHECKOUTHISTORY:
        jj_consume_token(CHECKOUTHISTORY);
        tmpStr = sString();
                                                    setValue(state, "checkoutHistory", tmpStr);
        break;
      case OWNER:
        jj_consume_token(OWNER);
        tmpSet = lList();
                                                    setValue(state, "ownerAccess", tmpSet);
        break;
      case PUBLIC:
        jj_consume_token(PUBLIC);
        tmpSet = lList();
                                                    setValue(state, "publicAccess", tmpSet);
        break;
      case ACTION:
        jj_consume_token(ACTION);
        tmpStr = sString();
                                                    setValue(state, "actionProgram", tmpStr);
        jj_consume_token(INPUT);
        tmpStr = sString();
                                                    setValue(state, "actionInput", tmpStr);
        break;
      case CHECK:
        jj_consume_token(CHECK);
        tmpStr = sString();
                                                    setValue(state, "checkProgram", tmpStr);
        jj_consume_token(INPUT);
        tmpStr = sString();
                                                    setValue(state, "checkInput", tmpStr);
        break;
      case ROUTE:
        jj_consume_token(ROUTE);
        tmpSet = lsList();
                                                    setValue(state, "routeUsers", tmpSet);
        tmpStr = sString();
                                                    setValue(state, "routeMessage", tmpStr);
        break;
      case USER:
        stateUser(state);
        break;
      case TRIGGER:
        stateTrigger(state);
        break;
      case SIGNATURE:
        stateSignature(state);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException_mxJPO();
      }
    }
    jj_consume_token(78);
        appendValue(_policy, "states", state);
  }

  final public void stateUser(final Policy_mxJPO.State _state) throws ParseException_mxJPO {
    final Policy_mxJPO.UserAccess userAccess = new Policy_mxJPO.UserAccess();
    String user, filter = null;
    Set<String> accessSet;
    jj_consume_token(USER);
    user = slString();
    accessSet = lList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FILTER:
      jj_consume_token(FILTER);
      filter = sString();
      break;
    default:
      ;
    }
        setValue(userAccess, "userRef", user);
        setValue(userAccess, "access", accessSet);
        setValue(userAccess, "expressionFilter", filter);
        appendValue(_state, "userAccess", userAccess);
  }

  final public void stateTrigger(final Policy_mxJPO.State _state) throws ParseException_mxJPO {
    final Policy_mxJPO.Trigger trigger = new Policy_mxJPO.Trigger();
    String tmp;
    jj_consume_token(TRIGGER);
    tmp = sString();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ACTION:
      jj_consume_token(ACTION);
                       setValue(trigger, "name", tmp + "Action");
      break;
    case CHECK:
      jj_consume_token(CHECK);
                           setValue(trigger, "name", tmp + "Check");
      break;
    case OVERRIDE:
      jj_consume_token(OVERRIDE);
                              setValue(trigger, "name", tmp + "Override");
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException_mxJPO();
    }
    tmp = sString();
                             setValue(trigger, "program", tmp);
    jj_consume_token(INPUT);
    tmp = sString();
                                     setValue(trigger, "arguments", tmp);
        appendValue(_state, "triggersStack", trigger);
  }

  final public void stateSignature(final Policy_mxJPO.State _state) throws ParseException_mxJPO {
    final Policy_mxJPO.Signature signature = new Policy_mxJPO.Signature();
    String tmpStr;
    Set<String> tmpSet;
    jj_consume_token(SIGNATURE);
    tmpStr = sString();
                                    setValue(signature, "name", tmpStr);
    jj_consume_token(77);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FILTER:
      case APPROVE:
      case IGNORE:
      case REJECT:
      case BRANCH:
        ;
        break;
      default:
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BRANCH:
        jj_consume_token(BRANCH);
        tmpStr = sString();
                                         setValue(signature, "branch", tmpStr);
        break;
      case APPROVE:
        jj_consume_token(APPROVE);
        tmpSet = lList();
                                         setValue(signature, "approverUsers", tmpSet);
        break;
      case IGNORE:
        jj_consume_token(IGNORE);
        tmpSet = lList();
                                         setValue(signature, "ignoreUsers", tmpSet);
        break;
      case REJECT:
        jj_consume_token(REJECT);
        tmpSet = lList();
                                         setValue(signature, "rejectUsers", tmpSet);
        break;
      case FILTER:
        jj_consume_token(FILTER);
        tmpStr = sString();
                                         setValue(signature, "filter", tmpStr);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException_mxJPO();
      }
    }
    jj_consume_token(78);
        appendValue(_state, "signatures", signature);
  }

  final public Set<String> lsList() throws ParseException_mxJPO {
    Token_mxJPO tmp;
    Set<String> ret = new HashSet<String>();
    jj_consume_token(LS_CURLY_BRACKET_OPEN);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LS_STRING:
      case LS_SINGLE_STRING:
        ;
        break;
      default:
        break label_4;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LS_STRING:
        tmp = jj_consume_token(LS_STRING);
                                     ret.add(tmp.image.replaceAll("^\"", "").replaceAll("\"$", "").replaceAll("\\\\\\\"", "\"").replaceAll("\\\\\\{", "{").replaceAll("\\\\\\}", "}"));
        break;
      case LS_SINGLE_STRING:
        tmp = jj_consume_token(LS_SINGLE_STRING);
                                            ret.add(tmp.image.replaceAll("\\\\\\\"", "\""));
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException_mxJPO();
      }
    }
    jj_consume_token(LS_CURLY_BRACKET_CLOSE);
        {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public Set<String> lList() throws ParseException_mxJPO {
    Token_mxJPO tmp;
    Set<String> ret = new HashSet<String>();
    jj_consume_token(L_CURLY_BRACKET_OPEN);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case L_STRING:
      case L_SINGLE_STRING:
      case L2_CURLY_BRACKET_OPEN:
        ;
        break;
      default:
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case L_STRING:
        tmp = jj_consume_token(L_STRING);
                                    ret.add(tmp.image.replaceAll("^\"", "").replaceAll("\"$", "").replaceAll("\\\\\\\"", "\"").replaceAll("\\\\\\{", "{").replaceAll("\\\\\\}", "}"));
        break;
      case L_SINGLE_STRING:
        tmp = jj_consume_token(L_SINGLE_STRING);
                                           ret.add(tmp.image.replaceAll("\\\\\\\"", "\""));
        break;
      case L2_CURLY_BRACKET_OPEN:
        jj_consume_token(L2_CURLY_BRACKET_OPEN);
        tmp = jj_consume_token(L3_BRACE_STRING);
                     ret.add(tmp.image);
        jj_consume_token(L4_CURLY_BRACKET_CLOSE);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException_mxJPO();
      }
    }
    jj_consume_token(L_CURLY_BRACKET_CLOSE);
        {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * Evaluates a simple string where a list must follow.
 *
 * @return evaluated simple string
 */
  final public String slString() throws ParseException_mxJPO {
    Token_mxJPO tmp;
    String ret;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SL_STRING:
      tmp = jj_consume_token(SL_STRING);
                             ret = tmp.image.replaceAll("^\"", "").replaceAll("\"$", "").replaceAll("\\\\\\\"", "\"").replaceAll("\\\\\\{", "{").replaceAll("\\\\\\}", "}");
      break;
    case SL_SINGLE_STRING:
      tmp = jj_consume_token(SL_SINGLE_STRING);
                                    ret = tmp.image.replaceAll("\\\\\\\"", "\"");
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException_mxJPO();
    }
        {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

/**
 * Evaluates a simple string.
 *
 * @return evaluated simple string
 */
  final public String sString() throws ParseException_mxJPO {
    Token_mxJPO tmp;
    String ret;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case S_STRING:
      tmp = jj_consume_token(S_STRING);
                            ret = tmp.image.replaceAll("^\"", "").replaceAll("\"$", "").replaceAll("\\\\\\\"", "\"").replaceAll("\\\\\\{", "{").replaceAll("\\\\\\}", "}");
      break;
    case S_SINGLE_STRING:
      tmp = jj_consume_token(S_SINGLE_STRING);
                                   ret = tmp.image.replaceAll("\\\\\\\"", "\"");
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException_mxJPO();
    }
        {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public PolicyDefParserTokenManager_mxJPO token_source;
  SimpleCharStream_mxJPO jj_input_stream;
  /** Current token. */
  public Token_mxJPO token;
  /** Next token. */
  public Token_mxJPO jj_nt;
  private int jj_ntk;

  /** Constructor with InputStream. */
  public PolicyDefParser_mxJPO(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public PolicyDefParser_mxJPO(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream_mxJPO(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new PolicyDefParserTokenManager_mxJPO(jj_input_stream);
    token = new Token_mxJPO();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token_mxJPO();
    jj_ntk = -1;
  }

  /** Constructor. */
  public PolicyDefParser_mxJPO(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream_mxJPO(stream, 1, 1);
    token_source = new PolicyDefParserTokenManager_mxJPO(jj_input_stream);
    token = new Token_mxJPO();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token_mxJPO();
    jj_ntk = -1;
  }

  /** Constructor with generated Token Manager. */
  public PolicyDefParser_mxJPO(PolicyDefParserTokenManager_mxJPO tm) {
    token_source = tm;
    token = new Token_mxJPO();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(PolicyDefParserTokenManager_mxJPO tm) {
    token_source = tm;
    token = new Token_mxJPO();
    jj_ntk = -1;
  }

  private Token_mxJPO jj_consume_token(int kind) throws ParseException_mxJPO {
    Token_mxJPO oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      return token;
    }
    token = oldToken;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token_mxJPO getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    return token;
  }

/** Get the specific Token. */
  final public Token_mxJPO getToken(int index) {
    Token_mxJPO t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  /** Generate ParseException. */
  public ParseException_mxJPO generateParseException() {
    Token_mxJPO errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException_mxJPO("Parse error at line " + line + ", column " + column + ".  Encountered: " + mess);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
